<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>hydromantes_note</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="hydromantes_note_files/libs/clipboard/clipboard.min.js"></script>
<script src="hydromantes_note_files/libs/quarto-html/quarto.js"></script>
<script src="hydromantes_note_files/libs/quarto-html/popper.min.js"></script>
<script src="hydromantes_note_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="hydromantes_note_files/libs/quarto-html/anchor.min.js"></script>
<link href="hydromantes_note_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="hydromantes_note_files/libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="hydromantes_note_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="hydromantes_note_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="hydromantes_note_files/libs/bootstrap/bootstrap-5b9ebf70e0dee4d80a6e95f13f396b94.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<p><strong><em>HYDROMANTES PLATYCEPHALUS</em></strong> (Mount Lyell Salamander)<strong>. LENTIC HABITAT USE.</strong></p>
<p><em>Hydromantes platycephalus</em> is endemic to California’s Sierra Nevada mountains (USA), where it is found at elevations ranging from 1220 to 3658 m. Across its range, it is closely associated with damp, rocky habitats, including talus piles, bedrock outcrops, flat rocks on bedrock or decomposed granite, under rocks at the edge of streams, and in waterfall spray zones (Wake and Papenfuss 2005. <em>In</em> Lannoo [ed.], Amphibian Declines: The Conservation Status of United States Species, pp.&nbsp;783–784. University of California Press, Berkeley, California; Hansen and Shedd 2025. California Amphibians and Reptiles. Princeton University Press, Princeton, New Jersey). Despite the abundance of lakes and ponds in the higher elevations of the Sierra Nevada, many with rocky shorelines that seem suitable for <em>H. platycephalus</em>, we are not aware of any published accounts describing <em>H. platycephalus</em> utilizing lentic habitats. Rovito (2010. Mol. Ecol. 19: 4554–4571, Appendix) lists 45 localities where he collected <em>H. platycephalus</em>, 13 of which are described as lakes (e.g., “Peeler Lake”, “east side of Vogelsang Lake”). However, in all such cases, <em>H. platycephalus</em> were actually collected from seep habitat on the rocky slopes above the lake (Rovito, personal communication). In addition, a search of the Arctos online collection management system (https://arctos.database.museum/; 23 Oct 2025), a database that includes over 5 million records from natural and cultural history collections, produced 501 <em>H. platycephalus</em> records from 126 distinct localities. After removing the Rovito (2010) localities, only six of 82 localities (7%) are attributed to lentic habitats. As in Rovito (2010), for most or all of these locality descriptions, it is likely that a lake name was used as a general locator, but that the <em>H. platycephalus</em> specimens were actually collected from a nearby non-lentic habitat.</p>
<p>Here, we provide the first unambiguous description of <em>H. platycephalus</em> occupying lake habitats. Our observations were made in three distinct areas of the Sierra Nevada, including one each in Yosemite, Kings Canyon, and Sequoia National Parks. The diurnal and nocturnal surveys we employed in all three areas were conducted similarly, with surveyors walking slowly along the lake shore and inlet/outlet streams, and searching all habitats encountered, including rock crevices, overhanging banks, and sandy beaches. The surveyed lakes are typical of those found at high elevations in the Sierra Nevada, having shorelines composed almost entirely of granite or metavolcanic bedrock and boulder, interspersed with short stretches of sandy beach or overhanging banks covered with meadow vegetation. All lakes included in this study are located west of the Sierra Nevada crest.</p>
<p>In Yosemite National Park, in 2024, we surveyed an unnamed lake south of Mount Lyell (lake ID = 70413; 37.7197°N, -119.2805°W, WGS 84, 3322 m elev.) for <em>H. platycephalus</em>. This lake is located in the headwaters of the Lyell Fork of the Merced River, and has a surface area of 2.3 ha and a maximum depth of 10.5 m. On 22 July, PL and GL conducted a nocturnal survey (2130–2245 h) of 70413, including the talus habitat above the lake, and the northern inlet and northwestern shoreline of the lake itself. In the first 150 m of the inlet, we observed 11 adult <em>H. platycephalus</em> in bedrock, talus, moss, and meadow habitats bordering the creek. No individuals were observed in the talus habitat above the lake or along the northwestern lake shore. On 23 July, PL conducted a nocturnal survey of the entire shoreline of 70413 and associated inlet and outlet streams (2150–0200 h). No <em>H. platycephalus</em> were observed along the northern inlet where they were seen the previous night. However, a single salamander was observed on the northern shoreline, on a vegetated bank within 1 m of the lake. In 2025, PL, GL, and LW again searched 70413 for <em>H. platycephalus</em>. On 18 August, during a diurnal survey of the lake shore and associated inlet and outlet streams (1250–1750 h), no <em>H. platycephalus</em> were seen. On 19 August, we conducted a nocturnal survey (2100–2230 h) of the northern inlet and the northern lake shore. Two <em>H. platycephalus</em> were observed in the first 100 m of the inlet. On the northern lake shore, we found &gt; 60 <em>H. platycephalus</em> (Fig. 1). Nearly all were observed on moss, in meadow vegetation, or at the base of a grassy bank along a sandy beach, and within 0–0.5 m of the lake. Notably, of these approximately 60 <em>H. platycephalus</em>, three individuals were found submerged in nearshore portions of the lake. All three salamanders were alive, as evidenced by their movement when in the beam of a headlamp.</p>
<p>In Kings Canyon National Park, in 2025, PL and GL surveyed an unnamed lake west of Mount Goddard (site id = 10114; 37.1019°N, -118.7370°W, WGS 84, 3409 m elev.). This lake is at the headwaters of the South Fork San Joaquin River, and has a surface area of 6.6 ha and a maximum depth of 28.5 m. During diurnal surveys of 10114 conducted on 08 August and 09 August (1140–1710 h and 1050–1320 h, respectively) of the entire lake shoreline and associated inlets and outlets, we found a total of 7 <em>H. platycephalus</em> 20–50 m up the northeastern inlet (5 on 08 August, 2 on 09 August). During a nocturnal survey on 08 August (2120–2330 h) of the entire lake shoreline and northeastern inlet, we observed two <em>H. platycephalus</em> in the northeastern inlet and three on the lake shoreline. Of the three <em>H. platycephalus</em> found along the shoreline, two were under an overhanging grassy bank within 0–1 m of the lake and one was approximately 5 m from the lake shore on a dry, vegetated slope.</p>
<p>In Sequoia National Park, on 06 August 2011 (2030–2130 h), RK searched for <em>H. platycephalus</em> in seeps flowing over granite outcrops above and approximately 300 m west of an unnamed lake (lake id = 20279; 36.3582°N, -118.4711°W, WGS 84, 3315 m elev.) located in the headwaters of Coyote Creek. On 07 August 2011 (approximately 2100 h), RK searched similar habitat above and approximately 300 m west of an unnamed lake (site id = 20276; 36.3669°N, -118.4883°W, WGS 84, 3298 m elev.) located in the headwaters of Laurel Creek. Coyote and Laurel Creeks are tributaries of the Kern River. Despite the searched sites being 8.1 km and 6.5 km, respectively, southeast of the southernmost known <em>H. platycephalus</em> locality west of the Sierra Nevada crest (Wake and Papenfuss 2005), 5–10 <em>H. platycephalus</em> were found at each location. The Laurel Creek area was surveyed again in 2024 (by FP and RK) and 2025 (by JS and RK), with a focus on lake 20276. 20276 has a surface area of 1.7 ha and a maximum depth of 12.5 m. During 14–16 July 2024, we conducted one diurnal survey (0910–1210 h) and two nocturnal surveys (2130–2315 h) of the entire shoreline and associated inlet and outlet streams of 20276, and one nocturnal survey of the original bedrock outcrop locality (approximately 2200 h). During the diurnal survey of 20276, no <em>H. platycephalus</em> were found. During the two nocturnal surveys of 20276, we observed a total of 9 <em>H. platycephalus</em> (2 on 15 July, 7 on 16 July), all on the northeast shore. We found no <em>H. platycephalus</em> during the nocturnal survey at the original outcrop locality. In 2025, we repeated this survey, conducting one diurnal survey (12 July, 0900–1110 h) and two nocturnal surveys of the entire shoreline of 20276 (12 July, 2130–2345 h; 13 July, 2140–2310 h), and one nocturnal survey of the original outcrop locality (13 July, 2315–2345 h). Again, we found no <em>H. platycephalus</em> during the diurnal survey of 20276 or the nocturnal survey of the original outcrop locality. However, we observed 20–30 <em>H. platycephalus</em> during each of the two nocturnal surveys of 20276, concentrated on the southeast and northeast shorelines. In both years, <em>H</em>. <em>platycephalus</em> were observed on wet rocks and moss on the shore within 0–1 m of the lake.</p>
<p>Our observations of <em>H. platycephalus</em> indicate that, in addition to the known association of <em>H. platycephalus</em> with upland habitats in the Sierra Nevada, the species also utilizes lake shore habitats and even underwater littoral habitats of lakes. The unusually high abundance of <em>H. platycephalus</em> we observed along lake shores during some surveys suggests the previously unrecognized importance of these lentic habitats for this poorly-understood species. For <em>H. platycephalus</em> west of the Sierra Nevada crest, our observations in Sequoia National Park also extend the known range of <em>H. platycephalus</em> south by 3.9 km. This suggests the need for additional surveys of suitable habitats in this area to better describe the range of <em>H. platycephalus</em> in the southernmost Sierra Nevada.</p>
<p><span class="smallcaps">FIG. 1</span>. Seven adult <em>Hydromantes platycephalus</em> observed along the shoreline of lake 70413 in Yosemite National Park, USA during a nocturnal survey on 19 August 2025. Each salamander is indicated with a black arrow. The lake is visible in the immediate foreground.</p>
<p>PARKER R. LAND (parkerland29@gmail.com), GEORGIA Q. LATTIG (glattig24@coa.edu), and LEONIE M. WALDERICH, Sierra Nevada Aquatic Research Laboratory, University of California, Mammoth Lakes, California 93546, USA &amp; Earth Research Institute, University of California, Santa Barbara, California 93106, USA. JACOB W. STAINES, Resilience Institute Bridging Biological Training and Research, Quito, Ecuador; FOREST D. PERI and ROLAND A. KNAPP (roland.knapp@ucsb.edu), Sierra Nevada Aquatic Research Laboratory, University of California, Mammoth Lakes, California 93546, USA &amp; Earth Research Institute, University of California, Santa Barbara, California 93106, USA.</p>
<!--# Submit in .docx or .odf format via email attachment to Laine Giovanetto: lgiovanetto@ymail.com -->

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>